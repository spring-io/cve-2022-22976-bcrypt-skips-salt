package org.springframework.security.bcrypt.update;

import org.springframework.security.bcrypt.hashes.PasswordHash;

public class ConsoleUpdateView implements UpdateView {
	@Override
	public void updateStart() {
		System.out.printf("\u001b[93mInitiating password hash update...\u001b[0m%n");
	}

	@Override
	public void updateComplete(int recordsNeedingUpdating, int recordsUpdated) {
		String color = "\u001b[92m";
		if (recordsUpdated < recordsNeedingUpdating) {
			color = "\u001b[93m";
		}
		System.err.println(color + "========================================================================\u001b[0m");
		System.out.printf(color + "All done! %d needed updating, updated %d.%n", recordsNeedingUpdating, recordsUpdated);
		System.out.println(color + "Please consider running again with 'check' to confirm.\u001b[0m");
		System.err.println(color + "========================================================================\u001b[0m");
	}

	@Override
	public String adviseAboutDelegate(PasswordHash hash) {
		return System.console().readLine(
				"%n\u001b[93mPassword for record (\u001b[0m%s\u001b[93m) does not have the Spring Security BCrypt%nprefix. This means one of two things:%n%n" +
				"\t1.\u001b[0m Spring Security should ignore updating records like this one. Either %n%n" +
				"\t\u001b[93m2.\u001b[0m You will update your Spring application from doing, or%n%n" +
				"\t\t\u001b[96m@Bean%n" +
				"\t\tPasswordEncoder passwordEncoder() {%n" +
				"\t\t\treturn new BCryptPasswordEncoder(31);%n" +
				"\t\t}\u001b[0m%n%n" + "" +
				"\t   to instead do%n%n" +
				"\t\t\u001b[96m@Bean%n" +
				"\t\tPasswordEncoder passwordEncoder() {%n" +
				"\t\t\treturn PasswordEncoderFactories%n" +
				"\t\t\t\t.createDelegatingPasswordEncoder();%n" +
				"\t\t}\u001b[0m%n%n" +
				"\u001b[93mAre you able to change your application to use PasswordEncoderFactories?%nIf so, Spring Security will update records like this one. \u001b[0m(y/N)\u001b[93m?\u001b[0m ", hash.getId());
	}
}
