package org.springframework.security.bcrypt.update;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.StreamSupport;

import org.springframework.security.bcrypt.hashes.PasswordHash;
import org.springframework.security.bcrypt.hashes.PasswordHashRepository;

public class UpdateCommand {
	private static final Pattern BCRYPT_PATTERN = Pattern.compile("\\A\\$2(a|y|b)?\\$(\\d\\d)\\$[./0-9A-Za-z]{53}");

	private PasswordHashRepository<? extends PasswordHash> read;
	private PasswordHashRepository<? super PasswordHash> write;
	private final UpdateView view;

	public UpdateCommand(PasswordHashRepository<? extends PasswordHash> read,
						PasswordHashRepository<? super PasswordHash> write,
						UpdateView view) {
		this.read = read;
		this.write = write;
		this.view = view;
	}

	public void run() {
		new Run().run();
	}

	private class Run {
		boolean alreadyAdvisedAboutDelegate = false;
		boolean willUseDelegate = false;

		int recordsNeedingUpdating = 0;
		int recordsUpdated = 0;

		void run() {
			view.updateStart();
			StreamSupport.stream(read.findAll().spliterator(), false).filter(this::needsUpdating).forEach(this::updatePassword);
			view.updateComplete(this.recordsNeedingUpdating, this.recordsUpdated);
		}

		boolean needsUpdating(PasswordHash passwordHash) {
			String hash = passwordHash.getPasswordHash();
			if (hash == null) {
				return false;
			}
			if (hash.startsWith("{bcrypt}")) {
				hash = hash.substring(8);
			}
			Matcher matcher = BCRYPT_PATTERN.matcher(hash);
			if (!matcher.matches()) {
				return false;
			}
			return Integer.parseInt(matcher.group(2)) == 31;
		}

		void updatePassword(PasswordHash passwordHash) {
			this.recordsNeedingUpdating++;
			String oldHash = passwordHash.getPasswordHash();
			String newHash = computeHash(passwordHash);
			if (oldHash.equals(newHash)) {
				return;
			}
			passwordHash.setPasswordHash(newHash);
			write.save(passwordHash);
			this.recordsUpdated++;
		}

		String computeHash(PasswordHash passwordHash) {
			String hash = passwordHash.getPasswordHash();
			if (hash == null) {
				return null;
			}
			if (hash.startsWith("{bcrypt}")) {
				return hash.replace("{bcrypt}", "{bcrypt-0}");
			}
			if (BCRYPT_PATTERN.matcher(hash).matches()) {
				if (this.willUseDelegate) {
					return "{bcrypt-0}" + hash;
				}
				if (this.alreadyAdvisedAboutDelegate) {
					return hash;
				}
				String answer = view.adviseAboutDelegate(passwordHash);
				this.alreadyAdvisedAboutDelegate = true;
				if ("y".equalsIgnoreCase(answer) || "Yes".equalsIgnoreCase(answer)) {
					this.willUseDelegate = true;
				}
				if (this.willUseDelegate) {
					return "{bcrypt-0}" + hash;
				}
			}
			return hash;
		}
	}
}
