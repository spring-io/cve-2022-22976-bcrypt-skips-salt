package org.springframework.security.bcrypt.update;

import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;

import org.springframework.security.bcrypt.hashes.InMemoryPasswordHashRepository;
import org.springframework.security.bcrypt.hashes.PasswordHash;
import org.springframework.security.bcrypt.hashes.TestPasswordHashRepositories;
import org.springframework.security.bcrypt.check.CheckCommand;
import org.springframework.security.bcrypt.check.CheckView;
import org.springframework.security.bcrypt.hashes.PasswordHashRepository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

public class UpdateCommandTests {
	@Test
	void givenBadHashesWithPrefixThenUpdates() {
		UpdateView view = mock(UpdateView.class);
		InMemoryPasswordHashRepository hashes = TestPasswordHashRepositories.withPrefix();
		UpdateCommand command = new UpdateCommand(hashes, hashes, view);
		command.run();
		ArgumentCaptor<Integer> badRecordsCount = ArgumentCaptor.forClass(Integer.class);
		ArgumentCaptor<Integer> badRecordsUpdated = ArgumentCaptor.forClass(Integer.class);
		verify(view).updateComplete(badRecordsCount.capture(), badRecordsUpdated.capture());
		assertThat(badRecordsCount.getValue()).isEqualTo(badRecordsUpdated.getValue());
		verifyNoUpdatesNeeded(hashes);
	}

	@Test
	void givenBadHashesWithoutPrefixAndUserUsesDelegateThenUpdates() {
		UpdateView view = mock(UpdateView.class);
		PasswordHashRepository<PasswordHash> hashes = TestPasswordHashRepositories.withoutPrefix();
		given(view.adviseAboutDelegate(any())).willReturn("y");
		UpdateCommand command = new UpdateCommand(hashes, hashes, view);
		command.run();
		ArgumentCaptor<Integer> badRecordsCount = ArgumentCaptor.forClass(Integer.class);
		ArgumentCaptor<Integer> badRecordsUpdated = ArgumentCaptor.forClass(Integer.class);
		verify(view).updateComplete(badRecordsCount.capture(), badRecordsUpdated.capture());
		assertThat(badRecordsCount.getValue()).isEqualTo(badRecordsUpdated.getValue());
		verifyNoUpdatesNeeded(hashes);
	}

	@Test
	void givenBadHashesWithoutPrefixAndUserRefusesDelegateThenDoesNotUpdate() {
		UpdateView view = mock(UpdateView.class);
		PasswordHashRepository<PasswordHash> hashes = TestPasswordHashRepositories.withoutPrefix();
		given(view.adviseAboutDelegate(any())).willReturn("n");
		UpdateCommand command = new UpdateCommand(hashes, hashes, view);
		command.run();
		ArgumentCaptor<Integer> badRecordsCount = ArgumentCaptor.forClass(Integer.class);
		ArgumentCaptor<Integer> badRecordsUpdated = ArgumentCaptor.forClass(Integer.class);
		verify(view).updateComplete(badRecordsCount.capture(), badRecordsUpdated.capture());
		assertThat(badRecordsUpdated.getValue()).isEqualTo(0);
		verifyUpdatesNeeded(hashes);
	}

	@Test
	void givenOkayHashesThenUpdateComplete() {
		UpdateView view = mock(UpdateView.class);
		PasswordHashRepository<PasswordHash> hashes = TestPasswordHashRepositories.okay();
		UpdateCommand command = new UpdateCommand(hashes, hashes, view);
		command.run();
		ArgumentCaptor<Integer> badRecordsCount = ArgumentCaptor.forClass(Integer.class);
		ArgumentCaptor<Integer> badRecordsUpdated = ArgumentCaptor.forClass(Integer.class);
		verify(view).updateComplete(badRecordsCount.capture(), badRecordsUpdated.capture());
		assertThat(badRecordsCount.getValue()).isEqualTo(badRecordsUpdated.getValue()).isEqualTo(0);
		verifyNoUpdatesNeeded(hashes);
	}

	@Test
	void givenBadHashesAndUserRefusesDelegateThenUpdates() {
		UpdateView view = mock(UpdateView.class);
		PasswordHashRepository<PasswordHash> hashes = TestPasswordHashRepositories.hashes();
		given(view.adviseAboutDelegate(any())).willReturn("No");
		UpdateCommand command = new UpdateCommand(hashes, hashes, view);
		command.run();
		ArgumentCaptor<Integer> badRecordsCount = ArgumentCaptor.forClass(Integer.class);
		ArgumentCaptor<Integer> badRecordsUpdated = ArgumentCaptor.forClass(Integer.class);
		verify(view).updateComplete(badRecordsCount.capture(), badRecordsUpdated.capture());
		assertThat(badRecordsCount.getValue()).isEqualTo(2 * badRecordsUpdated.getValue());
		verifyUpdatesNeeded(hashes);
	}

	@Test
	void givenBadHashesAndUserUsesDelegateThenUpdates() {
		UpdateView view = mock(UpdateView.class);
		PasswordHashRepository<PasswordHash> hashes = TestPasswordHashRepositories.hashes();
		given(view.adviseAboutDelegate(any())).willReturn("yes");
		UpdateCommand command = new UpdateCommand(hashes, hashes, view);
		command.run();
		ArgumentCaptor<Integer> badRecordsCount = ArgumentCaptor.forClass(Integer.class);
		ArgumentCaptor<Integer> badRecordsUpdated = ArgumentCaptor.forClass(Integer.class);
		verify(view).updateComplete(badRecordsCount.capture(), badRecordsUpdated.capture());
		assertThat(badRecordsCount.getValue()).isEqualTo(badRecordsUpdated.getValue());
		verifyNoUpdatesNeeded(hashes);
	}

	private void verifyNoUpdatesNeeded(PasswordHashRepository<PasswordHash> hashes) {
		CheckView view = mock(CheckView.class);
		CheckCommand command = new CheckCommand(hashes, view);
		command.run();
		verify(view).noUpdatesNeeded();
	}

	private void verifyUpdatesNeeded(PasswordHashRepository<PasswordHash> hashes) {
		CheckView view = mock(CheckView.class);
		CheckCommand command = new CheckCommand(hashes, view);
		command.run();
		verify(view).updatesNeeded();
	}
}
